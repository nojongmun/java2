package com.ict.edu;

public class Ex01 {
	// 클래스
	// 정의 : 객체(Object,인스턴스)를 만들기 위한 모든 정보를 담고 있는 파일(설계도면, 거푸집 등로 표현)
	// 클래스가 가지고 있는 것 : 상태값(데이터), 기능, 생성자
	//  1. 상태값 = 데이터(변수, 상수)           => 멤버필드
	//  2. 기능 = 동작                                                => 멤버메소드
	//  3. 생성자  = 클래스를 객체로 만들때 호출되는 것 => 생성자
	
	// 클래스의 구조 : 헤더, 멤버필드, 멤버메소드, 생성자
	// 1. 헤더 : [접근제한자][클래스종류] class 클래스이름{멤버필드,멤버메소드,생성자}
	//  1) 접근제한자 : 클래스, 필드, 메소드에 모두 사용
	//               외부에서 접근할 수 있는 권한의 단계를 말함
	//    public > protected > 생략(default) > private
	//    public : 누구나 다 접근 가능
	//    protected : 같은 패키지와 상속관계에 있어야만 접근 가능
	//    생략   :  같은 패키지에 있어야만 접근가능
	//    private : 외부에서는 절대 접근 불가, 내부 멤버(필드,메소드)끼리 접근 가능
	
	//  2) 클래스 종류 : 현재 클래스의 종류를 표시하는 부분
	//               일반적인 클래스는 이부분 생략한다.
	//               특정클래스를 만들고 특정 클래스에 해당하는 예약어를 사용(final, abstract)
	
	//  3) class  : 클래스임을 나타내는 예약어
	
	//  4) 클래스이름 : 저장이름, 첫글자 대문자 나머지 소문자, 공백/특수문자 사용X
	//               두단어 이상일때 단어의 첫글자는 대문자
	
	// 2. 멤버필드(변수와 상수) : 상태값, 데이터, 속성, 특징
	//  1) 변수 : 언제든지 변할 수 있는 데이터
	//           첫글자 소문자, 두단어이상일때 단어의 첫글자는 대문자, 공백/특수문자 사용X
	
	//  2) 상수 : 한번 저장되면 변경할 수 없는 데이터
	//           모든 글자가 대문자, 단어와 단어 사이에 '_'를 사용할 수 있다.
	
	// 3. 멤버메소드 : 기능, 동작, 하는 것 
	//             - 해당 메소드를 **호출(실행)하면 해당 메소드 안에 존재하는 내용이 **실행된다.
	//             - 메소드는 다른 메소드를 호출 할 수 있다.
	//             - 해당 메소드가 끝나면 호출한 곳으로 다시 되돌아 갑니다.
	//  1) 메소드 구성 : [접근제한자][메소드종류] 반환형  메소드이름([인자=매개변수]){ 실행문  }
	//   가. 접근제한자 : class의 접근제한자와 같음
	//                public > protected > 생략 > private 
	//   나. 메소드 종류 : 일반메소드는 이 부분을 생략한다.
	//                 특정 메소드일때 해당 예약어를 사용한다.(static) 
	//   다. 반환형 : 해당 메소드를 호출한 곳으로 결과를 가지고 되돌아 갈때 
	//              그 결과의 자료형을 말하다.
	//              만약 결과를 가지고  가지 않을 경우는 void 라는 예약어를 사용한다.
	//      예) public static void main(String[] args){}
	//        => 위의 메소드는 main 메소드라고 하고, main 메소드는 JVM이 호출한다.
	//           main 메소드가 끝났을 때 결과를 가지고 가지 않는다는 뜻이다.
	//   라. 메소드 이름 : 변수이름 만드는 방법과 같음
	//                 첫글자 소문자, 두단어이상일때 단어의 첫글자는 대문자, 공백/특수문자 사용X  
	//   마. 인자 : 메소드가 실행할 때  필요한 정보를 외부에서 받을 때 사용한다.
	//            생략 가능, 
	//            ** 메소드 이름이 같아도 인자 의 갯수와 자료형이 다르면  다른 메소드로 판단한다.
	//   ** 오버로딩 : 하나의 클래스 안에 같은 이름을 가진 메소드가 여러개 존재하는 것을 말함    
	//              단, 인자의 갯수와 자료형이 달라야 한다.
	//   ** getter() : 메소드를 이용해서 변수값을 가져올때 (호출하는 입장), 보낼때(메소드자체 입장)
	//   ** setter() : 메소드를 이용해서 변수값을 변경할때 
	
	// 4. 생성자 : 클래스를 객체로 만들 때 한번 호출 된다.
	//  1) 목적 : 멤버필드(변수와 상수)의 초기값 지정을 말한다.
	//  2) 구조 : 생성자는 클래스이름과 같다. 반환형이 없는 메소드와 같다.
	//           Scanner sc = new Scanner(System.in);
	//            클래스                          생성자
	//  3) 모든 클래스는 생성자를 가지고 있다.
	//     생성자가 없으면 기본 생성자가 생략 되어 있다.
	//     기본생성자란 인자가 없는 생성자이다. (기본생성자 : 클래스이름() );
	//     생성자는 오버로딩이 가능하다.즈, 하나의 클래스 안에 여러개의 생성자가 존재 할  수 있다.
	//
	//  ** 객체 생성 방법 **
	//  클래스이름  참조변수 = new 생성자 ;
	//  Scanner scan = new Scanner(System.in);
	
	// 객체를 만드는 이유 : 멤버필드, 멤버메소드를 사용하기 위해서 
	// 멤버필드와 멤버 메소드를  사용하기 위한 접근법 ; 참조변수.멤버필드,  참조변수.멤버메소드()
	//                                 예)  scan.next(), scan.nextInt();
	
	///////////////////////////////////////////////////////////////////////
	/*
      static과 instance : 멤버필드와 멤버 메소드에 해당 하는 내용
      1. instance 
          - instance 필드 또는 메소드 : 객체가 생성 될때 함께 생성되는 필드와 메소드를 말하다.  
          - 일반적인 멤버필드와 멤버 메소드가 여기에 속한다.
          - 접근법 : 참조변수.멤버필드,  참조변수.멤버메소드()
          
      2. static 
         - 객체 생성과 상관 없이 미리 만들어진 멤버필드, 멤버메소드
         - static 이라는 별도의 메모리에 생성된다.     
         - static이라는 예약어 만드시 사용한다.
         - instance 와 다르게 객체를 생성하지 않고 사용 가능
         - 접근법 : 클래스이름.멤버필드,  클래스이름.멤버메소드()
	 */
	
	
	
	
	
	
	
}








